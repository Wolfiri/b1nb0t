import urllib
import requests
import json
import calendar
import datetime
import base64

from pyquery import PyQuery as PQ

from disco.bot import Plugin, Config, CommandLevels


BASE_URL = 'https://iptorrents.eu'
LOGIN_URL = BASE_URL + '/take_login.php'
SEARCH_URL = BASE_URL + '/t'

CSRF_ERROR_CODE = 409
UNAUTHORIZED_ERROR_CODE = 401
CSRF_HEADER = 'X-Transmission-Session-Id'

# UNIX epochs to be turned into UTC datetimes
TIMESTAMP_KEYS = frozenset(
    ['activityDate',
     'addedDate',
     'dateCreated',
     'doneDate',
     'startDate',
     'lastAnnounceStartTime',
     'lastAnnounceTime',
     'lastScrapeStartTime',
     'lastScrapeTime',
     'nextAnnounceTime',
     'nextScrapeTime'])


class UTC(datetime.tzinfo):
    def utcoffset(self, dt):
        return datetime.timedelta(0)

    def tzname(self, dt):
        return 'UTC'

    def dst(self, dt):
        return datetime.timedelta(0)


def epoch_to_datetime(value):
    return datetime.datetime.fromtimestamp(value, UTC())


def datetime_to_epoch(value):
    if isinstance(value, datetime.datetime):
        return calendar.timegm(value.utctimetuple())
    elif isinstance(value, datetime.date):
        value = datetime.datetime(value.year, value.month, value.day)
        return calendar.timegm(value.utctimetuple())


class TransmissionJSONDecoder(json.JSONDecoder):
    def __init__(self, **kwargs):
        return super(TransmissionJSONDecoder, self).__init__(
            object_hook=self.object_hook, **kwargs)

    def object_hook(self, obj):
        for key, value in obj.items():
            if key in TIMESTAMP_KEYS:
                value = epoch_to_datetime(value)
            obj[key] = value
        return obj


class TransmissionJSONEncoder(json.JSONEncoder):
    def default(self, value):
        # datetime is a subclass of date, so this'll catch both
        if isinstance(value, datetime.date):
            return datetime_to_epoch(value)
        else:
            return value


class TransmissionClient(object):
    def __init__(self, url, path='/transmission/rpc',
                 username=None, password=None):
        """
        Initialize the Transmission client.
        The default host, port and path are all set to Transmission's
        default.
        """
        self.url = url + path
        self.headers = {}
        self.tag = 0

        self.auth = None
        if username or password:
            self.auth = (username, password)

    def __call__(self, method, **kwargs):
        """
        Send request to Transmission's RPC interface.
        """
        response = self._make_request(method, **kwargs)
        return self._deserialize_response(response)

    def _make_request(self, method, **kwargs):
        body = json.dumps(self._format_request_body(method, **kwargs), cls=TransmissionJSONEncoder)
        r = requests.post(self.url, data=body, headers=self.headers, auth=self.auth, verify=False)

        if r.status_code == CSRF_ERROR_CODE:
            self.headers[CSRF_HEADER] = r.headers[CSRF_HEADER]
            return self._make_request(method, **kwargs)

        r.raise_for_status()
        return r

    def _format_request_body(self, method, **kwargs):
        """
        Create a request object to be serialized and sent to Transmission.
        """
        fixed = {}
        # As Python can't accept dashes in kwargs keys, replace any
        # underscores with them here.
        for k, v in kwargs.items():
            fixed[k.replace('_', '-')] = v
        return {"method": method, "tag": self.tag, "arguments": fixed}

    def _deserialize_response(self, response):
        """
        Return the response generated by the request object, raising
        BadRequest if there were any problems.
        """
        doc = json.loads(response.text, cls=TransmissionJSONDecoder)

        if doc['result'] != 'success':
            raise Exception('Request failed: `%s`' % doc['result'])

        if doc['tag'] != self.tag:
            raise Exception('Tag mismatch: (got %s expected %s)' % (doc['tag'], self.tag))
        else:
            self.tag += 1

        if 'arguments' in doc:
            return doc['arguments'] or None
        return None


class TorrentPluginConfig(Config):
    user_id = None
    token = None
    session = None

    transmission_username = None
    transmission_password = None
    transmission_url = None


@Plugin.with_config(TorrentPluginConfig)
class TorrentPlugin(Plugin):
    def load(self, ctx):
        super(TorrentPlugin, self).load(ctx)
        self._session = None
        self.last = None
        self.client = TransmissionClient(
            url=self.config.transmission_url,
            username=self.config.transmission_username,
            password=self.config.transmission_password,
        )

    @property
    def cookies(self):
            return {
                'uid': self.config.user_id,
                'pass': self.config.token,
                'PHPSESSID': self.config.session
            }

    @Plugin.command('search', '<name:str...>', group='torrent', level=CommandLevels.TRUSTED)
    def search(self, event, name):
        r = requests.get(SEARCH_URL, params=urllib.urlencode({
            'q': name,
        }), cookies=self.cookies)
        r.raise_for_status()

        torrents = list(self._torrents_from_html(r.content))
        if not len(torrents):
            return event.msg.reply('No results')

        event.msg.reply('Results:\n```{}```'.format(
            '\n'.join(['{0}  {1} ({3})'.format(idx, *torrent) for idx, torrent in enumerate(torrents[:10])])
        ))

        self.last = torrents

    @Plugin.command('download', '<id:int>', group='torrent', level=CommandLevels.TRUSTED)
    def download(self, event, id):
        obj = self.last[id]
        r = requests.get(BASE_URL + obj[1], cookies=self.cookies)
        r.raise_for_status()
        r = self.client('torrent-add',
            metainfo=base64.b64encode(r.content),
            paused=False,
            peer_limit=500)

        hsh = None
        if 'torrent-added' in r:
            hsh = r['torrent-added']['hashString']
        elif 'torrent-duplicate' in r:
            hsh = r['torrent-duplicate']['hashString']

        if hsh:
            event.msg.reply('Ok, downloading torrent with hash {}'.format(hsh))
        else:
            event.msg.reply('Error: ```{}```'.format(r))

    def _torrents_from_html(self, raw):
        q = PQ(raw)

        torrents = q("#torrents")("tr")

        if not len(torrents):
            raise StopIteration

        torrents = torrents[1:]

        if len(list(torrents[-1].iterchildren())) == 1:
            raise StopIteration

        for torrent in torrents:
            parts = list(torrent.iterchildren())

            title = list(parts[1].iterchildren())[0].text_content()
            url = list(parts[3].iterchildren())[0].attrib['href']
            size = parts[5].text_content()
            yield title, url, size
